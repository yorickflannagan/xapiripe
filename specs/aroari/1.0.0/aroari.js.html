<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: aroari.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: aroari.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file Módulo criptográfico de alto nível (implementa a RFC 2986 e a seção 5 da RFC 5652)
 * @copyright Copyleft &amp;copy; 2021-2022 by The Crypthing Initiative - All rights reversed
 * @author Marco Antonio Gutierrez&lt;yorick.flannagan@gmail.com>
 */

'use strict';

const Hamahiri = require('../../hamahiri/lib/hamahiri');

/**
 * Objetos globais
 * @namespace Xapiripe
 */
/**
 * Referência um certificado digital
 * @class Certificate
 * @memberof Xapiripe
 * @property { string } subject - Titular do certificado
 * @property { string } issuer  - Emissor do certificado
 * @property { string } serial  - Número de série do certificado, onde os bytes são representados em hexadecimal
 * @property { Number } handle  - Handle para acesso à chave privada associada ao certificado
 */


/**
 * Referências ao módulo nativo
 * @namespace Hamahiri
 */
/**
 * Detalhamento dos erros ocorridos no processamento nativo
 * @class Failure
 * @extends Error
 * @memberof Hamahiri
 * @property { string } component - Componente que disparou o erro
 * @property { string } method    - Método ou função que disparou o erro
 * @property { Number } errorCode - Código Xapiripë do erro
 * @property { Number } apiError  - Código do erro gerado pela API de terceiros (por exemplo, a Windows CryptoAPI)
 */

/**
 * Módulo criptográfico de alto nível
 * @namespace Aroari
 */

/**
 * Detalhamento dos erros ocorridos no processamento do componente
 * @extends Error
 * @memberof Aroari
 * @property { string } component - Componente que disparou o erro
 * @property { string } method    - Método ou função que disparou o erro
 * @property { Number } errorCode - Código do erro
 * @property { Object } native    - Erro gerado no processamento nativo, se for o caso. Ver {@link Hamahiri.Failure}
 */
 class APIError extends Error
{
	/**
	 * Falha na enumeração de dispositivos criptográficos
	 * @member { Number }
	 * @default 64
	 */
	static ENUM_DEVICES_ERROR = 64;

	/**
	 * Argumento inválido
	 * @member { Number }
	 * @default 65
	 */
	 static ARGUMENT_ERROR = 65;

	/**
	 * Falha na enumeração de certificados de assinatura
	 * @member { Number }
	 * @default 66
	 */
	 static ENUM_CERTIFICATES_ERROR = 66;
	
	constructor(msg, method, errorCode, native)
	{
		super(msg);
		this.component = 'Aroari';
		this.method = method;
		this.errorCode = errorCode;
		this.native = native ? native : null;
	}
}

/**
 * Nome distinto X.500 para a caracterização do titular do certificado a ser utilizado
 * @class X500Name
 * @memberof Aroari
 * @property { String } c  - País da AC (country). Opcional
 * @property { String } o  - Organização da Autoridade Certificadora (organization). Opcional
 * @property { String } ou - Unidade organizacional da Autoridade Certificadora (organization unit). Opcional
 * @property { String } cn - Nome comum do titular do certificado (common name). Obrigatório
 */

/**
 * Opções para a geração de request de certificados.
 * @class EnrollOptions
 * @memberof Aroari
 * @property { String } device  - Cryptographic Service Provider ou Key Storage Provider que a ser utilizado para gerar
 * as chaves RSA. Deve corresponder exatamente a um dos dispositivos retornados por
 * {@link Aroari.enumerateDevices}
 * @property { Number } keySize - Tamanho (em bits) das chaves RSA a serem geradas. Opcional. Default: 2048
 * @property { Number } signAlg - Algoritmo a ser utilizado na assinatura da requisição de certificado. Opcional.
 * Default: SignMechanism.CKM_SHA256_RSA_PKCS
 * @property { Object } rdn     - Nome distinto do titular do certificado, conforme {@link Aroari.X500Name}. Obrigatório
 */


 const encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
 const equals = "=".charCodeAt(0);
 const dash = "-".charCodeAt(0);
 const decodings = [
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,
	 52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,
	 -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,
	 15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,
	 -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
	 41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
 ];
 const equals_value	= -2;
 const dash_value 	= -3;
 decodings[equals]	= equals_value;
 decodings[dash] 	= dash_value;
 const pre = 0;
 const content_1 = 1;
 const content_2 = 2;
 const content_3 = 3;
 const content_4 = 4;
 /**
  * Utilitário para conversão de e para Base64
  * @memberof Aroari
  */
 class Base64
 {
	 /**
	  * Converte um array de bytes para Base64
	  * @param { Uint8Array } bytes Cadeia de bytes a ser convertida
	  * @returns { String } Argumento convertido para Base64
	  */
	 static btoa(bytes)
	 {
		 var base64        = '';
		 var byteLength    = bytes.byteLength;
		 var byteRemainder = byteLength % 3;
		 var mainLength    = byteLength - byteRemainder;
		 var a, b, c, d;
		 var chunk;
		 for (var i = 0; i &lt; mainLength; i = i + 3)
		 {
			 chunk = (bytes[i] &lt;&lt; 16) | (bytes[i + 1] &lt;&lt; 8) | bytes[i + 2];
			 a = (chunk &amp; 16515072) >> 18;
			 b = (chunk &amp; 258048)   >> 12;
			 c = (chunk &amp; 4032)     >>  6;
			 d = chunk &amp; 63;
			 base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
		 }
		 if (byteRemainder == 1)
		 {
			 chunk = bytes[mainLength];
			 a = (chunk &amp; 252) >> 2;
			 b = (chunk &amp; 3)   &lt;&lt; 4;
			 base64 += encodings[a] + encodings[b] + '==';
		 }
		 else if (byteRemainder == 2)
		 {
			 chunk = (bytes[mainLength] &lt;&lt; 8) | bytes[mainLength + 1];
			 a = (chunk &amp; 64512) >> 10;
			 b = (chunk &amp; 1008)  >>  4;
			 c = (chunk &amp; 15)    &lt;&lt;  2;
			 base64 += encodings[a] + encodings[b] + encodings[c] + '=';
		 }
		 return base64;
	 }

	 /**
	  * Converte o argumento de Baser64 para um array de bytes
	  * @throws { Error } Dispara uma exceção caso a string não seja válida em Base64
	  * @param { String } base64 Array de bytes codificado em Base64
	  * @returns { Uint8Array } Array de bytes convertido
	  */
	 static atob(base64)
	 {
		 var charlen = base64.length;
		 var byteoff = 0;
		 var byteLength = Math.round(((charlen) / 4 * 3)+1);
		 var bytes = new Uint8Array(byteLength)
		 var chunk = 0;
		 var i = 0;
		 var code;
		 code = decodings[base64.charCodeAt(i)];
		 if (code == dash_value)
		 {
			 while (code == dash_value &amp;&amp; i &lt; charlen) code = decodings[base64.charCodeAt(++i)];
			 if (i!=0)
			 {
				 while(code != dash_value &amp;&amp; i &lt; charlen) code=decodings[base64.charCodeAt(++i)];
				 while(code == dash_value &amp;&amp; i &lt; charlen) code=decodings[base64.charCodeAt(++i)];
			 }
		 }
		 while(code&lt;0 &amp;&amp; code != dash_value &amp;&amp; i &lt; charlen) code=decodings[base64.charCodeAt(++i)];
		 if(code == dash_value || i >= charlen) throw new Error("A codificação recebida como base64 é inválida");
		 var stage = pre; 
		 while(i &lt; charlen &amp;&amp; code != dash_value) {
			 while(i &lt; charlen &amp;&amp; stage != content_4 &amp;&amp; code != dash_value)
			 {
				 stage++;
				 switch(stage)
				 {
					 case content_1:
						 chunk = code &lt;&lt; 18;
						 break;
					 case content_2:
						 chunk |= code &lt;&lt; 12;
						 break;
					 case content_3:
						 chunk |= code &lt;&lt; 6;
						 break;
					 case content_4:
						 chunk |= code;
						 break;
				 }
				 code = decodings[base64.charCodeAt(++i)];
				 while(code &lt; 0 &amp;&amp; code != dash_value &amp;&amp; i &lt; charlen) code = decodings[base64.charCodeAt(++i)];
			 }
			 switch(stage)
			 {
				 case content_1: throw new Error("A codificação recebida como base64 é inválida");
				 case content_4:	bytes[byteoff + 2] = chunk &amp;  255;
				 case content_3:	bytes[byteoff + 1] = chunk >> 8;
				 case content_2:	bytes[byteoff    ] = chunk >> 16;
			 }
			 byteoff += stage-1;
			 stage = pre;
		 }
		 return bytes.subarray(0,byteoff);
	 }
 }
 
/**
 * Implementa a parte cliente da emissão de um certificado digital
 * @memberof Aroari
 */
class Enroll
{
	constructor() { this.addon = new Hamahiri.Enroll(); }

	/**
	 * Enumera os dispositivos criptográficos presentes (Cryptographic Services Providers para RSA)
	 * @throws  { APIError } Dispara uma instância de {@link Aroari.APIError} em caso de falha
	 * @returns { Array } Lista de strings contendo os nomes dos dispositivos presentes
	 */
	enumerateDevices() {
		let ret = null;
		try { ret = this.addon.enumerateDevices(); }
		catch (err) { throw new APIError('Erro ao enumerar os dispositivos criptográficos', 'enumerateDevices', APIError.ENUM_DEVICES_ERROR, err); }
		return ret;
	}

	/**
	 * Gera um par de chaves RSA e assina uma requisição de certificado digital.
	 * @param   { Object   } options Parâmetros para operação conforme {@link Aroari.EnrollOptions}
	 * @throws  { APIError } Dispara uma instância de {@link Aroari.APIErrors} em caso de falha
	 * @returns { String   } Requisição PKCS #10 codificada em Base64 de acordo com a convenção PEM
	 */
	generateCSR(options) {
		if (!options) throw new APIError('Argumento EnrollOptions obrigatório', 'generateCSR', APIError.ARGUMENT_ERROR);
		if (typeof options.device  == 'undefined' || !isNaN(options.device)) throw new APIError('Argumento EnrollOptions.device obrigatório', 'generateCSR', APIError.ARGUMENT_ERROR);
		if (typeof options.keySize != 'undefined' &amp;&amp; isNaN(options.keySize)) throw new APIError('Argumento EnrollOptions.keySize, se presente, deve ser numérico', 'generateCSR', APIError.ARGUMENT_ERROR);
		if (typeof options.signAlg != 'undefined' &amp;&amp; isNaN(options.signAlg)) throw new APIError('Argumento EnrollOptions.signAlg, se presente, deve ser numérico', 'generateCSR', APIError.ARGUMENT_ERROR);
		if (typeof options.rdn == 'undefined' || typeof options.rnd.cn == 'undefined') throw new APIError('Argumento EnrollOptions.rdn deve, obrigatoriamente, incluir pelo menos a propriedade cn', 'generateCSR', APIError.ARGUMENT_ERROR);
		// TODO: implement generateCSR
	}

	/**
	 * Instala o certificado assinado e sua cadeia. O certificado de usuário final somente é instalado se for
	 * encontrada uma chave privada associada à sua chave pública no repositório do Windows. Toda a cadeia de
	 * certificados é criptograficamente verificada antes de sua instalação, sendo requerido o certificado
	 * de uma AC raiz.
	 * @param   { String   } pkcs7 Documento PKCS #7 codificado em Base64 de acordo com a convenção PEM emitido pela 
	 * AC para transporte do certificado do titular e a cadeia de Autoridades Certificadoras associada.
	 * @throws  { APIError } Dispara uma instância de {@link Aroari.APIErrors} em caso de falha.
	 * @returns { Boolean  } Retorna true se toda a cadeia de certificados de AC for instalada; caso um dos certificados
	 * de AC já esteja presente no repositório do Windows, retorna false.
	 */
	installCertificates(pkcs7) {
		if (!pkcs7) throw new APIError('Argumento pkcs7 é obrigatório', 'installCertificates', APIError.ARGUMENT_ERROR);
		// TODO: implement installCertificates
	}
}

/**
 * Opções para a operação de assinatura de documentos e transações
 * @class SignOptions
 * @memberof Aroari
 * @property { Number } handle Handle para o certificado, retornado por {@link Xapiripe.Certificate}
 * @property { String | ArrayBuffer } toBeSigned Documento ou transação a ser assinada
 * @property { Boolean } attach Indica se o documento toBeSigned deve ser anexado ao envelope CMS Signed Data. Opcional.
 * Valor default: true
 * @property { Number } algorithm Constante indicativa do algoritmo de assinatura a ser utilizado.
 * Valor default: SignMechanism.CKM_SHA256_RSA_PKCS
 * @property { String } policy Padrão de assinatura escolhido conforme a RFC 5126. Opcional. Valor default: CAdES-BES
 */

/**
 * Implementa as funções de assinatura digital utilizando chaves RSA
 * @memberof Aroari
 */
class Sign
{
	constructor() { this.addon = new Hamahiri.Sign(); }

	/**
	 * Enumera os certificados em vigor que estejam associados a chaves privadas RSA nos repositórios criptográficos
	 * @throws  { APIError } Dispara uma instância de {@link Aroari.APIErrors} em caso de falha.
	 * @returns { Array } Um array de objetos {@link Xapiripe.Certificate}
	 */
	enumerateCertificates() {
		let ret = null;
		try { ret = this.addon.enumerateCertificates(); }
		catch (err) { throw new APIError('Erro ao enumerar os certificados de assinatura presentes', 'enumerateCertificates', APIError.ENUM_CERTIFICATES_ERROR, err); }
		return ret;
	}

	/**
	 * Assina digitalmente um documento ou transação
	 * @param { Object } options Opções para a assinatura digital, conforme {@link Aroari.SignOptions}
	 * @throws  { APIError } Dispara uma instância de {@link Aroari.APIErrors} em caso de falha.
	 * @returns { String } Envelope CMS Signed Data, conforme a RFC 5652, codificado em Base64 de acordo com a convenção PEM
	 */
	sign(options) {
		if (!options) throw new APIError('Argumento SignOptions obrigatório', 'sign', APIError.ARGUMENT_ERROR);
		if (typeof options.handle == 'undefined' || isNaN(options.handle)) throw new APIError('Argumento SignOptions.handle deve ser obrigatoriamente numérico', 'sign', APIError.ARGUMENT_ERROR);
		if (!(typeof options.toBeSigned != 'undefined' &amp;&amp; (typeof options.toBeSigned == 'string' || options.toBeSigned instanceof ArrayBuffer))) throw new APIError('Argumento SignOptions.toBeSigned must be an string or an instance of ArrayBuffer', 'sign', APIError.ARGUMENT_ERROR);
		if (typeof options.attach != 'undefined' &amp;&amp; typeof options.attach != 'boolean') throw new APIError('Argumento SignOptions.attach, se presente, deve ser um valor lógico', 'sign', APIError.ARGUMENT_ERROR);
		if (typeof options.algorithm != 'undefined' &amp;&amp; isNaN(options.algorithm)) throw new APIError('Argumento SignOptions.algorithm, se presente, deve ser numérico', 'sign', APIError.ARGUMENT_ERROR);
		if (typeof options.policy != 'undefined' &amp;&amp; 'CAdES-BES'.localeCompare(options.policy) != 0) throw new APIError ('Argumento options.policy, se presente, deve ter um valor suportado', 'sign', APIError.ARGUMENT_ERROR);
	}
}

module.exports = {
	SignMechanism: Hamahiri.SignMechanism,
	AroariError: APIError,
	Enroll: Enroll,
	Sign: Sign,
	Base64: Base64
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Aroari.html">Aroari</a></li><li><a href="Hamahiri.html">Hamahiri</a></li><li><a href="Xapiripe.html">Xapiripe</a></li></ul><h3>Classes</h3><ul><li><a href="Aroari.APIError.html">APIError</a></li><li><a href="Aroari.Base64.html">Base64</a></li><li><a href="Aroari.Enroll.html">Enroll</a></li><li><a href="Aroari.EnrollOptions.html">EnrollOptions</a></li><li><a href="Aroari.Sign.html">Sign</a></li><li><a href="Aroari.SignOptions.html">SignOptions</a></li><li><a href="Aroari.X500Name.html">X500Name</a></li><li><a href="Hamahiri.Failure.html">Failure</a></li><li><a href="Xapiripe.Certificate.html">Certificate</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Thu Dec 23 2021 10:18:16 GMT-0300 (Horário Padrão de Brasília)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
